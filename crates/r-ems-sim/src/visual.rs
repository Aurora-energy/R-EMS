//! ---
//! ems_section: "11-simulation-test-harness"
//! ems_subsection: "module"
//! ems_type: "source"
//! ems_scope: "code"
//! ems_description: "Simulation runtime helpers and scenario engines."
//! ems_version: "v0.0.0-prealpha"
//! ems_owner: "tbd"
//! ---
use std::collections::HashMap;
use std::fs::{File, OpenOptions};
use std::io::{BufWriter, Write};
use std::path::Path;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{Duration, Instant};

use anyhow::Result;
use chrono::{DateTime, Utc};
use petgraph::graph::{Graph, NodeIndex};
use petgraph::visit::EdgeRef;
use r_ems_messaging::Envelope;
use rand::distributions::{Distribution, Uniform};
use rand::{rngs::StdRng, SeedableRng};
use rand_distr::Normal;
use serde::{Deserialize, Serialize};
use serde_json::json;
use uuid::Uuid;

/// Enumeration of supported component types for the visual grid builder.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum ComponentKind {
    Motor,
    Inverter,
    Battery,
    Cable,
    Breaker,
    #[serde(other)]
    Unknown,
}

/// Runtime simulation state stored for each component.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComponentState {
    pub voltage: f32,
    pub current: f32,
    pub power_kw: f32,
    pub temperature: f32,
    pub status: String,
}

impl Default for ComponentState {
    fn default() -> Self {
        Self {
            voltage: 0.0,
            current: 0.0,
            power_kw: 0.0,
            temperature: 25.0,
            status: "ok".to_string(),
        }
    }
}

/// Grid component as represented in the visual builder graph.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GridComponent {
    pub id: Uuid,
    pub name: String,
    pub kind: ComponentKind,
    pub parameters: serde_json::Value,
    pub position: (f32, f32),
    pub state: ComponentState,
}

impl GridComponent {
    pub fn new(name: impl Into<String>, kind: ComponentKind) -> Self {
        Self {
            id: Uuid::new_v4(),
            name: name.into(),
            kind,
            parameters: json!({}),
            position: (0.0, 0.0),
            state: ComponentState::default(),
        }
    }
}

/// Connection metadata shared between components.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Connection {
    pub resistance_ohm: f32,
    #[serde(default)]
    pub metadata: serde_json::Value,
}

impl Default for Connection {
    fn default() -> Self {
        Self {
            resistance_ohm: 0.01,
            metadata: json!({}),
        }
    }
}

/// Telemetry frame describing simulated runtime data for a single component.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComponentTelemetryFrame {
    pub timestamp: DateTime<Utc>,
    pub component_id: Uuid,
    pub name: String,
    pub kind: ComponentKind,
    pub state: ComponentState,
}

/// Scenarios that influence component behaviour profiles.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub enum ScenarioKind {
    Default,
    Fault,
    Overload,
    Blackout,
}

impl ScenarioKind {
    fn from_label(label: &str) -> Self {
        match label.to_lowercase().as_str() {
            "fault" => ScenarioKind::Fault,
            "overload" => ScenarioKind::Overload,
            "blackout" => ScenarioKind::Blackout,
            _ => ScenarioKind::Default,
        }
    }

    fn load_factor(self, tick: u64) -> f32 {
        let base = match self {
            ScenarioKind::Default => 0.55,
            ScenarioKind::Fault => 0.35,
            ScenarioKind::Overload => 0.95,
            ScenarioKind::Blackout => 0.0,
        };
        let modulation = ((tick as f32) / 60.0).sin() * 0.1;
        (base + modulation).clamp(0.0, 1.2)
    }
}

/// Faults that may be injected into components at runtime.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FaultKind {
    ShortCircuit,
    Overload,
    Disconnected,
}

/// Trait used by the REST API to forward fault commands into the running simulator.
pub trait SimulationControl: Send + Sync {
    fn inject_fault(&self, component_id: Uuid, fault: FaultKind) -> Result<()>;
}

/// Sink for telemetry frames generated by the grid simulator.
pub trait TelemetrySink: Send {
    fn publish(&mut self, frame: &ComponentTelemetryFrame) -> Result<()>;
}

/// Write telemetry frames into a JSONL file.
pub struct FileTelemetrySink {
    writer: BufWriter<File>,
}

impl FileTelemetrySink {
    pub fn open(path: impl AsRef<Path>) -> Result<Self> {
        let file = OpenOptions::new()
            .create(true)
            .write(true)
            .append(true)
            .open(path)?;
        Ok(Self {
            writer: BufWriter::new(file),
        })
    }
}

impl TelemetrySink for FileTelemetrySink {
    fn publish(&mut self, frame: &ComponentTelemetryFrame) -> Result<()> {
        let json = serde_json::to_vec(frame)?;
        self.writer.write_all(&json)?;
        self.writer.write_all(b"\n")?;
        self.writer.flush()?;
        Ok(())
    }
}

/// Telemetry sink that forwards frames to the shared messaging layer.
pub struct MessagingSink<T>
where
    T: Fn(Envelope<ComponentTelemetryFrame>) -> Result<()> + Send,
{
    publish: T,
}

impl<T> MessagingSink<T>
where
    T: Fn(Envelope<ComponentTelemetryFrame>) -> Result<()> + Send,
{
    pub fn new(publish: T) -> Self {
        Self { publish }
    }
}

impl<T> TelemetrySink for MessagingSink<T>
where
    T: Fn(Envelope<ComponentTelemetryFrame>) -> Result<()> + Send,
{
    fn publish(&mut self, frame: &ComponentTelemetryFrame) -> Result<()> {
        let envelope = Envelope::new(frame.clone());
        (self.publish)(envelope)
    }
}

/// Simulation engine dedicated to the visual grid builder.
#[derive(Debug)]
pub struct GridSimulationEngine {
    pub graph: Graph<GridComponent, Connection>,
    pub tick_ms: u64,
    pub noise_level: f32,
    pub scenario: ScenarioKind,
    rng: Mutex<StdRng>,
    faults: Arc<Mutex<HashMap<Uuid, FaultKind>>>,
}

impl GridSimulationEngine {
    pub fn new(
        graph: Graph<GridComponent, Connection>,
        tick_ms: u64,
        noise_level: f32,
        scenario: impl Into<String>,
        seed: u64,
    ) -> Self {
        Self {
            graph,
            tick_ms,
            noise_level,
            scenario: ScenarioKind::from_label(&scenario.into()),
            rng: Mutex::new(StdRng::seed_from_u64(seed)),
            faults: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Perform a single simulation step updating component states.
    pub fn step(&mut self, tick: u64) {
        let load_factor = self.scenario.load_factor(tick);
        let noise = self.noise_level;
        let mut rng = self.rng.lock().expect("rng poisoned");
        let normal = Normal::new(0.0, noise.max(1e-3) as f64).unwrap();
        let uniform = Uniform::new(0.8, 1.2);

        let faults = self.faults.lock().expect("fault map poisoned").clone();

        for node_idx in self.graph.node_indices().collect::<Vec<_>>() {
            let mut component = self
                .graph
                .node_weight_mut(node_idx)
                .expect("node must exist")
                .clone();
            let mut state = component.state.clone();
            let component_fault = faults.get(&component.id).cloned();
            match component.kind {
                ComponentKind::Motor => {
                    let rated_kw = value_or(&component.parameters, "rated_kw", 7.5);
                    let rated_v = value_or(&component.parameters, "rated_voltage", 400.0);
                    let efficiency = value_or(&component.parameters, "efficiency", 0.92);
                    let load = adjust_with_noise(load_factor, &mut *rng, &uniform);
                    let power = rated_kw * load;
                    let sqrt3 = (3.0_f32).sqrt();
                    let current = if rated_v > 0.0 {
                        (power * 1000.0) / (sqrt3 * rated_v * efficiency.max(0.1))
                    } else {
                        0.0
                    };
                    state.voltage = rated_v + normal.sample(&mut *rng) as f32;
                    state.current = current.max(0.0);
                    state.power_kw = power.max(0.0);
                    state.temperature = 30.0 + 45.0 * load + (noise * 10.0);
                    state.status = "ok".to_string();
                }
                ComponentKind::Inverter => {
                    let dc_kw = value_or(&component.parameters, "dc_input_kw", 12.0);
                    let efficiency = value_or(&component.parameters, "efficiency", 0.96);
                    let rated_v = value_or(&component.parameters, "ac_voltage", 400.0);
                    let load = adjust_with_noise(load_factor, &mut *rng, &uniform);
                    let ac_kw = dc_kw * efficiency * load;
                    let sqrt3 = (3.0_f32).sqrt();
                    let current = if rated_v > 0.0 {
                        (ac_kw * 1000.0) / (sqrt3 * rated_v)
                    } else {
                        0.0
                    };
                    state.voltage = rated_v + normal.sample(&mut *rng) as f32;
                    state.current = current;
                    state.power_kw = ac_kw;
                    state.temperature = 28.0 + 35.0 * load;
                    state.status = "ok".to_string();
                }
                ComponentKind::Battery => {
                    let mut soc = value_or(&component.parameters, "soc", 0.65);
                    let capacity_kw = value_or(&component.parameters, "capacity_kw", 15.0);
                    let rated_v = value_or(&component.parameters, "voltage", 380.0);
                    let direction = if load_factor > 0.6 { -1.0 } else { 1.0 };
                    soc = (soc + direction * 0.005).clamp(0.05, 0.95);
                    let power = capacity_kw * (soc - 0.5);
                    let current = if rated_v > 0.0 {
                        (power * 1000.0) / rated_v
                    } else {
                        0.0
                    };
                    state.voltage = rated_v + normal.sample(&mut *rng) as f32;
                    state.current = current;
                    state.power_kw = power;
                    state.temperature = 25.0 + (soc - 0.5).abs() * 30.0;
                    state.status = format!("soc_{:.0}%", soc * 100.0);
                    component.parameters = set_parameter(component.parameters, "soc", soc);
                }
                ComponentKind::Cable => {
                    let downstream_current = self.downstream_current(node_idx);
                    let resistance = self
                        .graph
                        .edges(node_idx)
                        .map(|edge| edge.weight().resistance_ohm)
                        .sum::<f32>()
                        .max(0.01);
                    let voltage_drop = downstream_current * resistance;
                    state.current = downstream_current;
                    state.voltage = 400.0 - voltage_drop;
                    state.power_kw = (state.voltage * state.current) / 1000.0;
                    state.temperature = 25.0 + downstream_current.abs() * 0.5;
                    state.status = if downstream_current.abs()
                        > value_or(&component.parameters, "rated_current", 60.0)
                    {
                        "overload".to_string()
                    } else {
                        "ok".to_string()
                    };
                }
                ComponentKind::Breaker => {
                    let downstream_current = self.downstream_current(node_idx);
                    let rated = value_or(&component.parameters, "rated_current", 80.0);
                    if downstream_current.abs() > rated
                        || matches!(component_fault, Some(FaultKind::ShortCircuit))
                    {
                        state.status = "open".to_string();
                        state.current = 0.0;
                        state.voltage = 0.0;
                        state.power_kw = 0.0;
                        state.temperature = 35.0;
                    } else {
                        state.status = "closed".to_string();
                        state.current = downstream_current;
                        state.voltage = 400.0;
                        state.power_kw = (state.voltage * state.current) / 1000.0;
                        state.temperature = 32.0;
                    }
                }
                ComponentKind::Unknown => {
                    state.status = "offline".to_string();
                    state.voltage = 0.0;
                    state.current = 0.0;
                    state.power_kw = 0.0;
                    state.temperature = 25.0;
                }
            }

            if let Some(fault) = component_fault {
                apply_fault(&mut state, fault);
            }

            if let Some(node) = self.graph.node_weight_mut(node_idx) {
                node.state = state;
                node.parameters = component.parameters;
            }
        }
    }

    /// Run the simulation loop for a fixed duration, pushing telemetry to sinks.
    pub fn run(
        &mut self,
        duration: Duration,
        mut sinks: Vec<Box<dyn TelemetrySink>>,
    ) -> Result<()> {
        let tick_interval = Duration::from_millis(self.tick_ms.max(1));
        let start = Instant::now();
        let mut tick: u64 = 0;
        while start.elapsed() < duration {
            self.step(tick);
            let frames = self.frames();
            for frame in &frames {
                for sink in sinks.iter_mut() {
                    sink.publish(frame)?;
                }
            }
            tick += 1;
            thread::sleep(tick_interval);
        }
        Ok(())
    }

    /// Materialise current component states into telemetry frames.
    pub fn frames(&self) -> Vec<ComponentTelemetryFrame> {
        self.graph
            .node_weights()
            .map(|component| ComponentTelemetryFrame {
                timestamp: Utc::now(),
                component_id: component.id,
                name: component.name.clone(),
                kind: component.kind.clone(),
                state: component.state.clone(),
            })
            .collect()
    }

    fn downstream_current(&self, node_idx: NodeIndex) -> f32 {
        let mut total = 0.0;
        for edge in self.graph.edges(node_idx) {
            let target = edge.target();
            if let Some(component) = self.graph.node_weight(target) {
                total += component.state.current;
            }
        }
        total
    }
}

impl SimulationControl for GridSimulationEngine {
    fn inject_fault(&self, component_id: Uuid, fault: FaultKind) -> Result<()> {
        let mut faults = self.faults.lock().expect("fault map poisoned");
        faults.insert(component_id, fault);
        Ok(())
    }
}

fn apply_fault(state: &mut ComponentState, fault: FaultKind) {
    match fault {
        FaultKind::ShortCircuit => {
            state.status = "fault".to_string();
            state.voltage = 0.0;
            state.current *= 3.0;
            state.temperature += 25.0;
        }
        FaultKind::Overload => {
            state.status = "fault".to_string();
            state.current *= 1.5;
            state.temperature += 15.0;
        }
        FaultKind::Disconnected => {
            state.status = "offline".to_string();
            state.current = 0.0;
            state.power_kw = 0.0;
            state.voltage = 0.0;
        }
    }
}

fn adjust_with_noise(load: f32, rng: &mut StdRng, distribution: &Uniform<f32>) -> f32 {
    (load * distribution.sample(rng)).clamp(0.0, 1.5)
}

fn value_or(parameters: &serde_json::Value, key: &str, default: f32) -> f32 {
    parameters
        .get(key)
        .and_then(|value| value.as_f64())
        .map(|value| value as f32)
        .unwrap_or(default)
}

fn set_parameter(mut value: serde_json::Value, key: &str, next: f32) -> serde_json::Value {
    match value {
        serde_json::Value::Object(ref mut map) => {
            map.insert(key.to_string(), serde_json::Value::from(next));
            value
        }
        _ => {
            let mut map = serde_json::Map::new();
            map.insert(key.to_string(), serde_json::Value::from(next));
            serde_json::Value::Object(map)
        }
    }
}
